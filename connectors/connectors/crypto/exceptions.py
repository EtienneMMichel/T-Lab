
class UnknownUserError(Exception): ...
class UnknownExchangeError(Exception): ...
class NotImplementedExchangeError(Exception): ...
class InvalidApiKeyError(Exception): ...
class InternalServerError(Exception): ...
class UnavailableProductError(Exception): ...
class UnsupportedProductError(Exception): ...
class ImmediateExecutionStopOrderError(Exception): ...
class InvalidContractError(Exception): ...
class UnauthorizedError(Exception): ...
class InvalidSymbolError(Exception): ...
class NotEnoughFundsError(Exception): ...
class InvalidSizeError(Exception): ...
class LimitModeOnlyError(Exception): ...
class RateLimitReachedError(Exception): ...
class StopLossOrderNotSupportedError(Exception): ...
class TakeProfitOrderNotSupportedError(Exception): ...
class UnsupportedOperationError(Exception): ...
class InvalidDataError(Exception): ...

class ForbiddenError(Exception): ...
class UnknownProductSymbolError(Exception): ...
class UnknownAssetSymbolError(Exception): ...
class UnknownCoinError(Exception): ...
class UnknownNetworkError(Exception): ...
class TooManyRequestsError(Exception): ...

class SubAccountOnlyEndpointError(Exception): ...
class MasterAccountOnlyEndpointError(Exception): ...

class UnknownVaultError(Exception): ...
class InvalidSourceTypeError(Exception): ...
class InvalidVaultAssetError(Exception): ...
class InvalidVaultAssetAmountError(Exception): ...
class UnauthorizedIBAN(Exception): ...
class UnknownIBAN(Exception): ...

class OrderNotFoundError(Exception):
    def __init__(self, order_id=None):
        self.order_id = order_id

    def __str__(self):
        return f"Order not found : '{self.order_id}'"

class UnableToCancelOrder(Exception):
    def __init__(self, order_id=None):
        self.order_id = order_id

    def __str__(self):
        return f"unable to cancel order : '{self.order_id}'"

class InvalidLeverage(Exception):
    def __init__(self, min_leverage, max_leverage):
        self.min_leverage = min_leverage
        self.max_leverage = max_leverage

    def __str__(self):
        return f"Invalid leverage: Shall be between {self.min_leverage} and {self.max_leverage}."

class InsufficientMarginError(Exception):
    def __init__(self, symbol, available_balance, required_additional_balance):
        self.symbol = symbol
        self.available_balance = available_balance
        self.required_additional_balance = required_additional_balance

    def __str__(self):
        return f"Insufficient Margin: Require {self.required_additional_balance} {self.symbol} additional balance, only {self.available_balance} {self.symbol} available."